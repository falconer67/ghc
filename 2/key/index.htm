<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hamster Keygen</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="../3.4.5"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <link href="../ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet">
    <script src="../react%4017.0.2/umd/react.production.min.js"></script>
    <script src="../react-dom%4017.0.2/umd/react-dom.production.min.js"></script>
    <script src="../%40babel/standalone%407.25.3/babel.min.js"></script>
    <script src="../npm/framer-motion%404.1.17/dist/framer-motion.min.js"></script>
    <style>
        html {
            font-size: 16px;
        }
        @media (max-width: 640px) {
            html {
                font-size: 14px;
            }
        }
        body {
            min-width: 320px;
        }
		.rounded-full {
            border-radius: 25px !important;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 28px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }
        .custom-shadow {
            --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 65%), 0 1px 2px -1px rgb(0 0 0 / 42%);
            --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
        }
        .dark .custom-shadow {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity));
            --tw-shadow: 0 1px 2px 0 rgb(251 251 251 / 65%), 0 0px 0px 0px rgb(0 0 0);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
        }		
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #2196F3;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        .dark .toggle-slider {
            background-color: #555;
        }
        .dark input:checked + .toggle-slider {
            background-color: #3b82f6;
        }
        .key-card {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
        }
        .dark .key-card {
            background: linear-gradient(135deg, #3f4c6b 0%, #606c88 100%);
        }
        @media (max-width: 640px) {
            .key-card {
                font-size: 0.75rem;
            }
            .sm-stack {
                flex-direction: column;
            }
            .sm-stack > * {
                width: 100%;
                margin-bottom: 0.5rem;
            }
        }
        .notification {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
        }
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #f0f;
            animation: confettiAnimation 5s ease-in-out forwards;
        }
        @keyframes confettiAnimation {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .game-button {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            width: 48px;
            height: 48px;
            margin: 0 4px;
        }
        .game-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        .game-button img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: filter 0.3s ease;
        }
        .game-button.active {
            box-shadow: 0 0 0 2px #3b82f6;
        }
        .game-button.active img {
            filter: brightness(1.2);
        }
        .game-button::after {
            content: attr(data-game);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 0.6rem;
            transition: opacity 0.3s ease;
        }
        .game-container {
            background-size: cover;
            background-position: center;
            position: relative;
        }
        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.3));
            z-index: 1;
        }
        .game-container > * {
            position: relative;
            z-index: 2;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }
        .game-selector {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            z-index: 1000;
        }
        .settings-button {
            position: fixed;
            bottom: 64px;
            right: 16px;
            z-index: 1000;
        }
        .loading-icon-container {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            padding: 2px;
        }
        .container {
            max-width: 1020px !important;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        const { motion, AnimatePresence } = window.Motion;

        const LoadingIcon = () => (
            <svg className="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        const CheckIcon = () => (
            <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
        );

        const NotificationManager = () => {
            const [notifications, setNotifications] = useState([]);

            useEffect(() => {
                const showNotification = (message) => {
                    const id = Date.now();
                    setNotifications(prev => [...prev, { id, message }]);
                    setTimeout(() => {
                        setNotifications(prev => prev.filter(n => n.id !== id));
                    }, 3000);
                };

                window.showNotification = showNotification;

                return () => {
                    delete window.showNotification;
                };
            }, []);

            return (
                <div className="fixed bottom-40 left-1/2 transform -translate-x-1/2 z-50">
                    <AnimatePresence>
                        {notifications.map((notification, index) => (
                            <motion.div
                                key={notification.id}
                                initial={{ opacity: 0, y: 50, scale: 0.3 }}
                                animate={{ opacity: 1, y: 0, scale: 1 }}
                                exit={{ opacity: 0, scale: 0.5, transition: { duration: 0.2 } }}
                                transition={{ type: "spring", stiffness: 500, damping: 30 }}
                                className="bg-white dark:bg-gray-800 text-gray-800 dark:text-white px-4 py-2 rounded-lg shadow-lg text-sm mb-2"
                                style={{ marginBottom: `${index * 60}px` }}
                            >
                                {notification.message}
                            </motion.div>
                        ))}
                    </AnimatePresence>
                </div>
            );
        };

const App = () => {
    const [keySessions, setKeySessions] = useState({});
    const [globalSettings, setGlobalSettings] = useState({
        keyCount: 1,
        useNumbering: false,
        useQuotes: false,
        useLineSpacing: false,
        useFormatting: false,
        copyAllGames: false,
        debugMode: false,
        forPublication: false,
        deleteAfterCopy: false,
        dimCopiedKeys: true,
    });
    const [isGenerating, setIsGenerating] = useState({});
    const [showSettings, setShowSettings] = useState(false);
    const [theme, setTheme] = useState(() => {
        const savedTheme = localStorage.getItem('theme');
        return savedTheme || 'dark';
    });
    const [language, setLanguage] = useState(() => {
        const savedLanguage = localStorage.getItem('language');
        return savedLanguage || 'ru';
    });
    const [progress, setProgress] = useState({});
    const [statusText, setStatusText] = useState({});
    const [detailedStatus, setDetailedStatus] = useState({});
    const [currentSession, setCurrentSession] = useState({});
    const [activeGame, setActiveGame] = useState('Bike');
    const [isCompleted, setIsCompleted] = useState({
        Bike: false,
        Clone: false,
        Cube: false,
        Train: false,
        Merge: false
    });
    const [selectedSessions, setSelectedSessions] = useState({});
    const [copiedKeys, setCopiedKeys] = useState({});
    const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
    const [keysToDelete, setKeysToDelete] = useState(null);
    const [showClearConfirmation, setShowClearConfirmation] = useState(false);
const [keyCountPerGame, setKeyCountPerGame] = useState({
    Bike: 4,
    Clone: 4,
    Cube: 4,
    Train: 4,
    Merge: 4,
    Twerk: 4
});

const appConfigs = {
    Bike: {
        appToken: 'd28721be-fd2d-4b45-869e-9f253b554e50',
        promoId: '43e35910-c168-4634-ad4f-52fd764a843f',
        bgImage: 'img_bg/bg_bike.jpg',
        btnImage: 'img_btn/btn_bike.jpg'
    },
    Clone: {
        appToken: '74ee0b5b-775e-4bee-974f-63e7f4d5bacb',
        promoId: 'fe693b26-b342-4159-8808-15e3ff7f8767',
        bgImage: 'img_bg/bg_clone.jpg',
        btnImage: 'img_btn/btn_clone.jpg'
    },
    Cube: {
        appToken: 'd1690a07-3780-4068-810f-9b5bbf2931b2',
        promoId: 'b4170868-cef0-424f-8eb9-be0622e8e8e3',
        bgImage: 'img_bg/bg_chain.jpg',
        btnImage: 'img_btn/btn_chain.jpg'
    },
    Train: {
        appToken: '82647f43-3f87-402d-88dd-09a90025313f',
        promoId: 'c4480ac7-e178-4973-8061-9ed5b2e17954',
        bgImage: 'img_bg/bg_train.jpg',
        btnImage: 'img_btn/btn_miner.jpg'
    },
    Merge: {
        appToken: '8d1cc2ad-e097-4b86-90ef-7a27e19fb833',
        promoId: 'dc128d28-c45b-411c-98ff-ac7726fbaea4',
        bgImage: 'img_bg/bg_mergeaway.jpg',
        btnImage: 'img_btn/btn_mergeaway.jpg'
    },
    Twerk: {
        appToken: '61308365-9d16-4040-8bb0-2f4a4c69074c',
        promoId: '61308365-9d16-4040-8bb0-2f4a4c69074c',
        bgImage: 'img_bg/bg_twerk.jpg',
        btnImage: 'img_btn/btn_twerk.jpg'
    }
};

            const statusMessages = {
                ru: {
                    initializing: "Разминаем лапки перед генерацией...",
                    connecting: "Пытаемся достучаться до сервера...",
                    authenticating: "Проверяем, не самозванцы ли мы...",
                    generating: "Крутим хомячье колесо для создания ключа...",
                    verifying: "Проверяем, не сгрыз ли хомяк ключ...",
                    finalizing: "Полируем ключ до блеска...",
                    stopped: "Хомяк устал и прилёг отдохнуть.",
                },
                en: {
                    initializing: "Warming up before generation...",
                    connecting: "Trying to reach the server...",
                    authenticating: "Checking if we're not impostors...",
                    generating: "Spinning the hamster wheel to create a key...",
                    verifying: "Checking if the hamster didn't chew the key...",
                    finalizing: "Polishing the key to a shine...",
                    stopped: "The hamster got tired and lay down to rest.",
                }
            };

            const generationPhrases = {
                ru: [
                    "Крутим хомячье колесо для создания ключа...",
                    "Хомяк усердно работает над вашим ключом...",
                    "Подкармливаем хомяка для ускорения процесса...",
                    "Хомяк собирает буквы и цифры для вашего ключа...",
                    "Хомяк проверяет надежность ключа...",
                    "Хомяк полирует ключ до блеска...",
                    "Хомяк делает перерыв на обед... Шутка, он все еще работает!",
                    "Хомяк консультируется с коллегами по поводу вашего ключа...",
                    "Хомяк использует продвинутые алгоритмы для создания ключа...",
                    "Хомяк применяет магию для улучшения качества ключа..."
                ],
                en: [
                    "Spinning the hamster wheel to create a key...",
                    "The hamster is working hard on your key...",
                    "Feeding the hamster to speed up the process...",
                    "The hamster is collecting letters and numbers for your key...",
                    "The hamster is checking the reliability of the key...",
                    "The hamster is polishing the key to a shine...",
                    "The hamster is taking a lunch break... Just kidding, it's still working!",
                    "The hamster is consulting with colleagues about your key...",
                    "The hamster is using advanced algorithms to create the key...",
                    "The hamster is applying magic to improve the key quality..."
                ]
            };

            useEffect(() => {
                const savedSettings = localStorage.getItem('globalSettings');
                const savedKeySessions = localStorage.getItem('keySessions');
                if (savedSettings) setGlobalSettings(JSON.parse(savedSettings));
                if (savedKeySessions) setKeySessions(JSON.parse(savedKeySessions));
                document.documentElement.classList.toggle('dark', theme === 'dark');
            }, []);

            useEffect(() => {
                localStorage.setItem('globalSettings', JSON.stringify(globalSettings));
                localStorage.setItem('keySessions', JSON.stringify(keySessions));
                localStorage.setItem('theme', theme);
                localStorage.setItem('language', language);
                document.documentElement.classList.toggle('dark', theme === 'dark');
                document.documentElement.lang = language;
            }, [globalSettings, keySessions, theme, language]);

            const generateClientId = () => {
                const timestamp = Date.now();
                const randomNumbers = Array.from({ length: 19 }, () => Math.floor(Math.random() * 10)).join('');
                return `${timestamp}-${randomNumbers}`;
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const API = {
    async login(clientId, game, retries = 5) {
        for (let i = 0; i < retries; i++) {
            try {
                if (globalSettings.debugMode) {
                    await sleep(1000);
                    return 'debug-token';
                }
                const response = await fetch('https://api.gamepromo.io/promo/login-client', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ appToken: appConfigs[game].appToken, clientId, clientOrigin: 'deviceid' })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                return data.clientToken;
            } catch (error) {
                console.error(`Login attempt ${i + 1} failed:`, error);
                if (i === retries - 1) {
                    if (error.message === 'Failed to fetch') {
                        throw new Error(language === 'ru' ? 'Не удалось подключиться к серверу. Пожалуйста, проверьте ваше интернет-соединение.' : 'Failed to connect to the server. Please check your internet connection.');
                    } else {
                        throw new Error(language === 'ru' ? `Ошибка при авторизации: ${error.message}` : `Authentication error: ${error.message}`);
                    }
                }
                await sleep(2000);
            }
        }
    },
                async emulateProgress(clientToken, game) {
                    if (globalSettings.debugMode) {
                        await sleep(2000);
                        return true;
                    }
                    console.log('Sending request with:', {
                        promoId: appConfigs[game].promoId,
                        clientToken: clientToken
                    });
                    return fetch('https://api.gamepromo.io/promo/register-event', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${clientToken}`
                        },
                        body: JSON.stringify({
                            promoId: appConfigs[game].promoId,
                            eventId: crypto.randomUUID(),
                            eventOrigin: 'undefined'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(errData => {
                                throw new Error(JSON.stringify(errData));
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Response:', data);
                        return data.hasCode;
                    })
                    .catch(error => {
                        console.error('Error in emulateProgress:', error);
                        throw error;
                    });
                },
                async generateKey(clientToken, game) {
                    if (globalSettings.debugMode) {
                        await sleep(1000);
                        return `DEBUG-${game.toUpperCase()}-${Math.random().toString(36).substring(2, 15).toUpperCase()}`;
                    }
                    return fetch('https://api.gamepromo.io/promo/create-code', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${clientToken}`
                        },
                        body: JSON.stringify({ promoId: appConfigs[game].promoId })
                    }).then(response => response.json())
                      .then(data => data.promoCode);
                }
            };

const generateKeys = async (game) => {
    setIsGenerating(prev => ({ ...prev, [game]: true }));
    setProgress(prev => ({ ...prev, [game]: 0 }));
    setStatusText(prev => ({ ...prev, [game]: statusMessages[language].initializing }));
    setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Начало процесса' : 'Starting the process' }));
    setIsCompleted(prev => ({ ...prev, [game]: false }));
    
    let currentSessionKeys = [];
    let currentSessionId = null;
    
    try {
        const currentSessionCount = keySessions[game] ? keySessions[game].length : 0;
        currentSessionId = currentSessionCount + 1;
        
        for (let i = 0; i < keyCountPerGame[game]; i++) {
            try {
                const clientId = generateClientId();
                setStatusText(prev => ({ ...prev, [game]: statusMessages[language].connecting }));
                setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Подключение к серверу' : 'Connecting to server' }));
                const clientToken = await API.login(clientId, game);
                
                setStatusText(prev => ({ ...prev, [game]: statusMessages[language].authenticating }));
                setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Проверка доступа' : 'Access verification' }));
                await sleep(1000);
                
                let hasCode = false;
                for (let attempt = 0; attempt < 11; attempt++) {
                    setStatusText(prev => ({ ...prev, [game]: generationPhrases[language][Math.floor(Math.random() * generationPhrases[language].length)] }));
                    setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? `Попытка ${attempt + 1} из 11` : `Attempt ${attempt + 1} of 11` }));
                    
                    await sleep(20000 * (Math.random() / 3 + 1));
                    
                    try {
                        hasCode = await API.emulateProgress(clientToken, game);
                        setProgress(prev => ({ ...prev, [game]: (i + (attempt + 1) / 11) / keyCountPerGame[game] * 100 }));
                        if (hasCode) break;
                    } catch (error) {
                        console.error('Error in emulateProgress:', error);
                        if (error.message.includes('TooManyRegister')) {
                            setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? `Хомяк устал. Даем ему отдохнуть...` : `The hamster is tired. Letting it rest...` }));
                        } else {
                            setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? `Ой! Хомяк споткнулся. Пробуем снова...` : `Oops! The hamster stumbled. Trying again...` }));
                        }
                        await sleep(2000);
                    }
                }
                if (hasCode) {
                    setStatusText(prev => ({ ...prev, [game]: statusMessages[language].verifying }));
                    setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Проверка сгенерированного ключа' : 'Verifying generated key' }));
                    await sleep(1000);
                    
                    setStatusText(prev => ({ ...prev, [game]: statusMessages[language].finalizing }));
                    setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Получение сгенерированного ключа' : 'Retrieving generated key' }));
                    const key = await API.generateKey(clientToken, game);
                    
                    if (!currentSessionKeys.includes(key)) {
                        currentSessionKeys.push(key);
                        
                        setCurrentSession(prev => ({
                            ...prev,
                            [game]: { id: currentSessionId, keys: [...currentSessionKeys] }
                        }));
                        
                        if (currentSessionKeys.length === 4 || i === keyCountPerGame[game] - 1) {
                            setKeySessions(prevSessions => ({
                                ...prevSessions,
                                [game]: [...(prevSessions[game] || []), { id: currentSessionId, keys: [...currentSessionKeys] }]
                            }));
                            currentSessionKeys = [];
                            currentSessionId++;
                        }
                        
                        setProgress(prev => ({ ...prev, [game]: (i + 1) / keyCountPerGame[game] * 100 }));
                    } else {
                        i--;
                    }
                } else {
                    throw new Error(language === 'ru' ? 'Не удалось сгенерировать ключ после нескольких попыток' : 'Failed to generate key after several attempts');
                }
            } catch (error) {
                console.error(language === 'ru' ? 'Ошибка при генерации ключа ' : 'Error generating key ' + (i + 1) + ':', error);
                window.showNotification(language === 'ru' ? 'Хомяк устал и не смог сгенерировать ключ. Дайте ему отдохнуть и попробуйте снова.' : 'The hamster is tired and couldn\'t generate a key. Let it rest and try again.');
                setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? `Ошибка: Не удалось сгенерировать ключ` : `Error: Failed to generate key` }));
                await sleep(2000);
            }
        }
    } catch (error) {
        console.error(language === 'ru' ? 'Критическая ошибка при генерации ключей:' : 'Critical error generating keys:', error);
        window.showNotification(language === 'ru' ? 'Хомяк перетрудился и не может больше работать. Попробуйте позже.' : 'The hamster is overworked and can\'t work anymore. Try again later.');
    } finally {
        setIsGenerating(prev => ({ ...prev, [game]: false }));
        setProgress(prev => ({ ...prev, [game]: 0 }));
        setStatusText(prev => ({ ...prev, [game]: '' }));
        setDetailedStatus(prev => ({ ...prev, [game]: '' }));
        setCurrentSession(prev => ({ ...prev, [game]: null }));
        setIsCompleted(prev => ({ ...prev, [game]: true }));
        window.showNotification(language === 'ru' ? 
            `Хомяк закончил работу для ${game}. Создано ключей: ${keySessions[game].reduce((total, session) => total + session.keys.length, 0)}` :
            `The hamster finished working for ${game}. Keys created: ${keySessions[game].reduce((total, session) => total + session.keys.length, 0)}`
        );
    }
};

            const stopGeneration = (game) => {
                setIsGenerating(prev => ({ ...prev, [game]: false }));
                setStatusText(prev => ({ ...prev, [game]: statusMessages[language].stopped }));
                setDetailedStatus(prev => ({ ...prev, [game]: language === 'ru' ? 'Процесс остановлен пользователем' : 'Process stopped by user' }));
                window.showNotification(language === 'ru' ? `Хомяк прекратил генерацию ключей для ${game}` : `The hamster stopped generating keys for ${game}`);
            };

            const clearAllKeys = (game, clearAll = false) => {
                if (clearAll) {
                    setKeySessions({});
                    Object.keys(appConfigs).forEach(g => {
                        window.showNotification(language === 'ru' ? `Все ключи для ${g} удалены` : `All keys for ${g} deleted`);
                    });
                } else {
                    setKeySessions(prevSessions => ({
                        ...prevSessions,
                        [game]: []
                    }));
                    window.showNotification(language === 'ru' ? `Все ключи для ${game} удалены` : `All keys for ${game} deleted`);
                }
                setShowClearConfirmation(false);
            };

            const clearSession = (game, sessionId) => {
                setKeySessions(prevSessions => ({
                    ...prevSessions,
                    [game]: prevSessions[game].filter(session => session.id !== sessionId)
                }));
                window.showNotification(language === 'ru' ? `Сессия удалена для ${game}` : `Session deleted for ${game}`);
            };

            const formatKey = (key, number = null, game) => {
                let formattedKey = key;
                if (globalSettings.useQuotes) {
                    formattedKey = `\`${formattedKey}\``;
                }
                if (globalSettings.useNumbering && number !== null) {
                    formattedKey = `${number}. ${formattedKey}`;
                }
                return formattedKey;
            };

const formatKeysWithHashtags = (keys, game) => {
    const hashtags = {
        Bike: "#bikeride3d",
        Clone: "#myclonearmy",
        Cube: "#chaincube2048",
        Train: "#trainminer",
        Merge: "#mergeaway"  // Добавлен хэштег для Merge
    };
                
    let formattedKeys = `${hashtags[game]}\n`;
    formattedKeys += keys.map((key, index) => formatKey(key, index + 1, game)).join('\n');
    formattedKeys += '\n_________________________________\n';
    
    return formattedKeys;
};

            const copyKeys = (keys, game, sessionIds = []) => {
                let formattedKeys;
                if (globalSettings.useFormatting) {
                    formattedKeys = formatKeysWithHashtags(keys, game);
                } else {
                    formattedKeys = keys.map((key, i) => 
                        formatKey(key, globalSettings.useNumbering ? i + 1 : null, game)
                    ).join(globalSettings.useLineSpacing ? '\n\n' : '\n');
                }
                navigator.clipboard.writeText(formattedKeys);
                window.showNotification(language === 'ru' ? 
                    `${keys.length > 1 ? 'Ключи' : 'Ключ'} скопированы в буфер обмена` :
                    `${keys.length > 1 ? 'Keys' : 'Key'} copied to clipboard`
                );

                if (globalSettings.dimCopiedKeys) {
                    setCopiedKeys(prev => ({
                        ...prev,
                        [game]: [...new Set([...(prev[game] || []), ...keys])]
                    }));
                }

                if (globalSettings.deleteAfterCopy) {
                    setKeysToDelete({ game, sessionIds });
                    setShowDeleteConfirmation(true);
                }
            };

            const copyAllKeys = (game) => {
                if (globalSettings.copyAllGames) {
                    let allFormattedKeys = '';
                    let allSessionIds = {};
                    let allCopiedKeys = {};
                    Object.keys(appConfigs).forEach(g => {
                        if (keySessions[g] && keySessions[g].length > 0) {
                            const allKeys = keySessions[g].flatMap(session => session.keys);
                            allSessionIds[g] = keySessions[g].map(session => session.id);
                            allCopiedKeys[g] = allKeys;
                            if (globalSettings.useFormatting) {
                                allFormattedKeys += formatKeysWithHashtags(allKeys, g);
                            } else {
                                allFormattedKeys += `${g}:\n`;
                                allFormattedKeys += allKeys.map((key, i) => 
                                    formatKey(key, globalSettings.useNumbering ? i + 1 : null, g)
                                ).join(globalSettings.useLineSpacing ? '\n\n' : '\n');
                                allFormattedKeys += '\n\n';
                            }
                        }
                    });
                    navigator.clipboard.writeText(allFormattedKeys);
                    window.showNotification(language === 'ru' ? 'Все ключи скопированы в буфер обмена' : 'All keys copied to clipboard');

                    if (globalSettings.dimCopiedKeys) {
                        setCopiedKeys(prev => {
                            const newCopiedKeys = {...prev};
                            Object.entries(allCopiedKeys).forEach(([g, keys]) => {
                                newCopiedKeys[g] = [...new Set([...(newCopiedKeys[g] || []), ...keys])];
                            });
                            return newCopiedKeys;
                        });
                    }

                    if (globalSettings.deleteAfterCopy) {
                        setKeysToDelete(allSessionIds);
                        setShowDeleteConfirmation(true);
                    }
                } else {
                    const allKeys = keySessions[game] ? keySessions[game].flatMap(session => session.keys) : [];
                    const sessionIds = keySessions[game] ? keySessions[game].map(session => session.id) : [];
                    copyKeys(allKeys, game, sessionIds);
                }
            };

            const deleteKey = (game, sessionId, keyIndex) => {
                setKeySessions(prevSessions => ({
                    ...prevSessions,
                    [game]: prevSessions[game].map(session => 
                        session.id === sessionId
                            ? { ...session, keys: session.keys.filter((_, index) => index !== keyIndex) }
                            : session
                    ).filter(session => session.keys.length > 0)
                }));
                window.showNotification(language === 'ru' ? `Ключ удален для ${game}` : `Key deleted for ${game}`);
            };

            const toggleTheme = () => {
                setTheme(prevTheme => prevTheme === 'dark' ? 'light' : 'dark');
            };

            const toggleLanguage = () => {
                setLanguage(prevLang => prevLang === 'en' ? 'ru' : 'en');
            };

            const totalKeysCount = (game) => 
                (keySessions[game] ? keySessions[game].reduce((total, session) => total + session.keys.length, 0) : 0) +
                (currentSession[game] ? currentSession[game].keys.length : 0);

            const handleSessionSelect = (game, sessionId) => {
                setSelectedSessions(prev => {
                    const newSelectedSessions = { ...prev };
                    const gameSelectedSessions = { ...(newSelectedSessions[game] || {}) };
                    gameSelectedSessions[sessionId] = !gameSelectedSessions[sessionId];
                    newSelectedSessions[game] = gameSelectedSessions;

                    // Автоматический выбор аналогичных сессий в других играх
                    Object.keys(appConfigs).forEach(otherGame => {
                        if (otherGame !== game && keySessions[otherGame]) {
                            const otherGameSessions = keySessions[otherGame];
                            const analogSessionIndex = otherGameSessions.findIndex(session => session.id === sessionId);
                            if (analogSessionIndex !== -1) {
                                newSelectedSessions[otherGame] = {
                                    ...(newSelectedSessions[otherGame] || {}),
                                    [sessionId]: gameSelectedSessions[sessionId]
                                };
                            }
                        }
                    });

                    return newSelectedSessions;
                });
            };

            const copySelectedKeys = () => {
                let allSelectedKeys = {};
                let keysToDelete = {};

                Object.keys(appConfigs).forEach(game => {
                    allSelectedKeys[game] = [];
                    keysToDelete[game] = [];

                    (keySessions[game] || []).forEach(session => {
                        if (selectedSessions[game]?.[session.id]) {
                            allSelectedKeys[game].push(...session.keys);
                            keysToDelete[game].push(session.id);
                        }
                    });
                });

                let formattedKeys = '';
                Object.keys(allSelectedKeys).forEach(game => {
                    if (allSelectedKeys[game].length > 0) {
                        if (globalSettings.useFormatting) {
                            formattedKeys += formatKeysWithHashtags(allSelectedKeys[game], game);
                        } else {
                            formattedKeys += `${game}:\n`;
                            formattedKeys += allSelectedKeys[game].map((key, i) => 
                                formatKey(key, globalSettings.useNumbering ? i + 1 : null, game)
                            ).join(globalSettings.useLineSpacing ? '\n\n' : '\n');
                            formattedKeys += '\n\n';
                        }
                    }
                });

                navigator.clipboard.writeText(formattedKeys);
                window.showNotification(language === 'ru' ? 'Выбранные ключи скопированы в буфер обмена' : 'Selected keys copied to clipboard');

                if (globalSettings.dimCopiedKeys) {
                    setCopiedKeys(prev => {
                        let newCopiedKeys = {...prev};
                        Object.entries(allSelectedKeys).forEach(([game, keys]) => {
                            newCopiedKeys[game] = [...new Set([...(newCopiedKeys[game] || []), ...keys])];
                        });
                        return newCopiedKeys;
                    });
                }

                if (globalSettings.deleteAfterCopy) {
                    setKeysToDelete(keysToDelete);
                    setShowDeleteConfirmation(true);
                }

                // Сброс выбранных сессий после копирования
                setSelectedSessions({});
            };

            const getSelectedKeysCount = () => {
                return Object.keys(appConfigs).reduce((total, game) => {
                    return total + (keySessions[game] || []).reduce((gameTotal, session) => {
                        return gameTotal + (selectedSessions[game]?.[session.id] ? session.keys.length : 0);
                    }, 0);
                }, 0);
            };

            const confirmDelete = () => {
                if (keysToDelete) {
                    Object.entries(keysToDelete).forEach(([game, sessionIds]) => {
                        if (Array.isArray(sessionIds)) {
                            sessionIds.forEach(sessionId => {
                                clearSession(game, sessionId);
                            });
                        }
                    });
                }
                setShowDeleteConfirmation(false);
                setKeysToDelete(null);
            };

const MenuVariant2C2 = ({ isDarkMode, activeGame }) => {
    const [activeIndex, setActiveIndex] = useState(Object.keys(appConfigs).indexOf(activeGame));

    return (
        <div className="fixed bottom-4 left-0 w-full flex justify-center z-50">
            <div className={`flex flex-col justify-around items-center ${isDarkMode ? 'bg-gray-800' : 'bg-white'} rounded-full shadow-lg px-2 py-2 relative`}>
                <motion.div
                    className="absolute bg-blue-500 rounded-full"
                    layoutId="activeGameBackground"
                    transition={{ type: "spring", stiffness: 300, damping: 30 }}
                    style={{
                        width: `calc(33.33% - 8px)`,
                        height: `calc(50% - 8px)`,
                        left: `calc(${(activeIndex % 3) * 33.33}% + 4px)`,
                        top: `calc(${Math.floor(activeIndex / 3) * 50}% + 4px)`,
                    }}
                />
                {[0, 1].map(row => (
                    <div key={row} className="flex justify-around items-center w-full mb-2">
                        {Object.keys(appConfigs).slice(row * 3, (row + 1) * 3).map((game, index) => (
                            <motion.button 
                                key={game} 
                                onClick={() => {
                                    setActiveGame(game);
                                    setActiveIndex(row * 3 + index);
                                    if (isCompleted[game]) {
                                        setIsCompleted(prev => ({ ...prev, [game]: false }));
                                    }
                                }}
                                className={`relative flex items-center mx-1 px-3 py-2 rounded-full transition-all duration-300 z-10 ${
                                    game === activeGame 
                                        ? 'text-white'
                                        : isDarkMode
                                            ? 'text-gray-300 hover:text-white'
                                            : 'text-gray-600 hover:text-gray-800'
                                }`}
                            >
                                <div className="relative mr-2">
                                    <img src={appConfigs[game].btnImage} alt={game} className="w-8 h-8 rounded-full" />
                                    {isGenerating[game] && (
                                        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-full loading-icon-container">
                                            <LoadingIcon />
                                        </div>
                                    )}
                                    {isCompleted[game] && (
                                        <div className="absolute inset-0 flex items-center justify-center bg-green-500 bg-opacity-50 rounded-full">
                                            <CheckIcon />
                                        </div>
                                    )}
                                </div>
                                <div className="flex flex-col items-start">
                                    <span className={`text-xs font-medium ${
                                        game === activeGame
                                            ? 'text-white'
                                            : isDarkMode ? 'text-gray-300' : 'text-gray-700'
                                    }`}>{game}</span>
                                    <span className={`text-xs ${
                                        game === activeGame
                                            ? isDarkMode ? 'text-blue-200' : 'text-blue-100'
                                            : isDarkMode ? 'text-gray-400' : 'text-gray-500'
                                    }`}>
                                        {totalKeysCount(game)}
                                        {globalSettings.forPublication && (
                                            <span className="ml-1">
                                                ({(keySessions[game] || []).reduce((count, session) => 
                                                    count + (selectedSessions[game]?.[session.id] ? session.keys.length : 0), 0
                                                )})
                                            </span>
                                        )}
                                    </span>
                                </div>
                            </motion.button>
                        ))}
                    </div>
                ))}
            </div>
        </div>
    );
};

            return (
                <div className={`min-h-screen p-4 pb-24 ${theme === 'dark' ? 'dark' : ''}`}>
                    <nav className="bg-white dark:bg-gray-800 shadow-lg rounded-lg p-4 mb-8">
                        <div className="container mx-auto flex justify-between items-center">
                            <h1 className="text-xl font-bold text-gray-800 dark:text-white">TapTap generator</h1>
                            <div className="flex items-center space-x-4">
                                <motion.button 
                                    whileHover={{ scale: 1.1 }}
                                    whileTap={{ scale: 0.9 }}
                                    onClick={toggleLanguage}
                                    className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors duration-200"
                                >
                                    <span className="font-bold text-gray-800 dark:text-white">
                                        {language === 'eng' ? 'RUS' : 'ENG'}
                                    </span>
                                </motion.button>
                                <motion.button 
                                    whileHover={{ scale: 1.1 }}
                                    whileTap={{ scale: 0.9 }}
                                    onClick={toggleTheme}
                                    className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors duration-200"
                                >
                                    <motion.i 
                                        initial={false}
                                        animate={{ rotate: theme === 'dark' ? 180 : 0 }}
                                        transition={{ duration: 0.3 }}
                                        className={`fas ${theme === 'dark' ? 'fa-sun text-yellow-400' : 'fa-moon'}`}
                                    />
                                </motion.button>
                            </div>
                        </div>
                    </nav>
                    <main className="container mx-auto">
                        <GameContainer
                            key={activeGame}
                            game={activeGame}
                            appConfig={appConfigs[activeGame]}
                            isGenerating={isGenerating[activeGame]}
                            progress={progress[activeGame]}
                            statusText={statusText[activeGame]}
                            detailedStatus={detailedStatus[activeGame]}
                            currentSession={currentSession[activeGame]}
                            keySessions={keySessions[activeGame]}
                            globalSettings={globalSettings}
                            setGlobalSettings={setGlobalSettings}
                            onGenerateKeys={() => generateKeys(activeGame)}
                            onStopGeneration={() => stopGeneration(activeGame)}
                            onClearAllKeys={() => setShowClearConfirmation(true)}
                            onClearSession={(sessionId) => clearSession(activeGame, sessionId)}
                            onCopyKeys={(keys) => copyKeys(keys, activeGame)}
                            onCopyAllKeys={() => copyAllKeys(activeGame)}
                            onDeleteKey={(sessionId, keyIndex) => deleteKey(activeGame, sessionId, keyIndex)}
                            totalKeysCount={totalKeysCount(activeGame)}
                            selectedSessions={selectedSessions[activeGame]}
                            onSessionSelect={(sessionId) => handleSessionSelect(activeGame, sessionId)}
                            copiedKeys={copiedKeys[activeGame]}
                            keyCount={keyCountPerGame[activeGame]}
                            setKeyCount={(count) => setKeyCountPerGame(prev => ({ ...prev, [activeGame]: count }))}
                            language={language}
                        />
                    </main>
                    <MenuVariant2C2 isDarkMode={theme === 'dark'} activeGame={activeGame} />
                    {globalSettings.forPublication && (
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={copySelectedKeys}
                            className="fixed bottom-28 left-1/2 transform -translate-x-1/2 p-2 bg-green-500 hover:bg-green-600 text-white rounded transition-colors duration-200 flex items-center z-50"
                            style={{ width: 'auto', minWidth: '200px', justifyContent: 'center' }}
                        >
                            <i className="fas fa-copy mr-2"></i>
                            {language === 'ru' ? 'Копировать выбранное' : 'Copy selected'}
                            <span className="ml-2 bg-green-600 px-2 py-1 rounded-full text-xs">
                                {getSelectedKeysCount()}
                            </span>
                        </motion.button>
                    )}
                    <motion.button
                        whileHover={{ scale: 1.1 }}
                        whileTap={{ scale: 0.9 }}
                        onClick={() => window.open('https://t.me/hamsterkombatkeygen', '_blank')}
                        className="contact-button p-3 bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-lg transition-colors duration-200"
                        style={{ position: 'fixed', bottom: '128px', right: '16px', zIndex: 1000 }}
                    >
                        <i className="fas fa-envelope"></i>
                    </motion.button>
                    <motion.button
                        whileHover={{ scale: 1.1 }}
                        whileTap={{ scale: 0.9 }}
                        onClick={() => setShowSettings(true)}
                        className="settings-button p-3 bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-lg transition-colors duration-200"
                        style={{ position: 'fixed', bottom: '64px', right: '16px', zIndex: 1000 }}
                    >
                        <i className="fas fa-cog"></i>
                    </motion.button>
                    <AnimatePresence>
                        {showSettings && (
                            <SettingsModal
                                globalSettings={globalSettings}
                                setGlobalSettings={setGlobalSettings}
                                onClose={() => setShowSettings(false)}
                                language={language}
                            />
                        )}
                    </AnimatePresence>
                    <AnimatePresence>
                        {showDeleteConfirmation && (
                            <DeleteConfirmationModal
                                onConfirm={confirmDelete}
                                onCancel={() => setShowDeleteConfirmation(false)}
                                language={language}
                            />
                        )}
                    </AnimatePresence>
                    <AnimatePresence>
                        {showClearConfirmation && (
                            <ClearConfirmationModal
                                onConfirmCurrent={() => clearAllKeys(activeGame)}
                                onConfirmAll={() => clearAllKeys(activeGame, true)}
                                onCancel={() => setShowClearConfirmation(false)}
                                language={language}
                            />
                        )}
                    </AnimatePresence>
                    <NotificationManager />
                </div>
            );
        };

        const GameContainer = ({
            game,
            appConfig,
            isGenerating,
            progress,
            statusText,
            detailedStatus,
            currentSession,
            keySessions,
            globalSettings,
            setGlobalSettings,
            onGenerateKeys,
            onStopGeneration,
            onClearAllKeys,
            onClearSession,
            onCopyKeys,
            onCopyAllKeys,
            onDeleteKey,
            totalKeysCount,
            selectedSessions,
            onSessionSelect,
            copiedKeys,
            keyCount,
            setKeyCount,
            language
        }) => {
            const [isCopyingAll, setIsCopyingAll] = useState(false);

            const handleCopyAll = () => {
                onCopyAllKeys();
                setIsCopyingAll(true);
                setTimeout(() => setIsCopyingAll(false), 1000);
            };

            return (
                <div className="game-container bg-white dark:bg-gray-800 rounded-lg shadow-lg mb-20 overflow-hidden">
                    <div 
                        className="bg-cover bg-center h-auto p-4 relative"
                        style={{ backgroundImage: `url(${appConfig.bgImage})` }}
                    >
                        <div className="absolute inset-0 bg-black bg-opacity-50"></div>
                        <div className="relative z-10">
                            <h2 className="text-lg font-bold mb-3 text-white">
                                {language === 'ru' ? `Генератор ключей для ${game}` : `Key generator for ${game}`}
                            </h2>
                            <div className="mb-3 flex items-center">
                                <label className="block mr-2 text-white text-sm">
                                    {language === 'ru' ? 'Количество ключей:' : 'Number of keys:'}
                                </label>
                                <input
                                    type="number"
                                    value={keyCount}
                                    onChange={(e) => {
                                        const value = e.target.value;
                                        if (value === '' || parseInt(value) >= 0) {
                                            setKeyCount(value);
                                        }
                                    }}
                                    onBlur={() => {
                                        const count = parseInt(keyCount);
                                        if (isNaN(count) || count < 1) {
                                            setKeyCount(1);
                                        } else {
                                            setKeyCount(count);
                                        }
                                    }}
                                    className="w-16 p-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white mr-2 text-sm"
                                />
                                {isGenerating && (
                                    <div className="text-white text-sm">
                                        {language === 'ru' 
                                            ? `Генерируется: ${currentSession ? currentSession.keys.length + 1 : 1} из ${keyCount}`
                                            : `Generating: ${currentSession ? currentSession.keys.length + 1 : 1} of ${keyCount}`
                                        }
                                    </div>
                                )}
                            </div>
                            <motion.button
                                whileHover={{ scale: 1.05 }}
                                whileTap={{ scale: 0.95 }}
                                onClick={isGenerating ? onStopGeneration : onGenerateKeys}
                                className={`w-full p-2 rounded text-white text-sm transition-colors duration-200 ${
                                    isGenerating ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'
                                }`}
                            >
                                {isGenerating 
                                    ? (language === 'ru' ? 'Остановить генерацию' : 'Stop generation')
                                    : (language === 'ru' ? 'Сгенерировать ключи' : 'Generate keys')
                                }
                            </motion.button>
                            {isGenerating && (
                                <div className="mt-3">
                                    <div className="w-full bg-gray-200 rounded-full h-2 dark:bg-gray-700">
                                        <div className="bg-blue-600 h-2 rounded-full" style={{width: `${progress}%`}}></div>
                                    </div>
                                    <p className="text-center mt-2 text-white text-sm">{statusText}</p>
                                    <p className="text-center text-xs text-gray-300 mt-1 h-6 overflow-hidden">{detailedStatus}</p>
                                </div>
                            )}
                        </div>
                    </div>
                    {(keySessions && keySessions.length > 0 || currentSession) && (
                        <div className="p-4 bg-gray-100 dark:bg-gray-900 mt-4 rounded-lg">
                            <div className="flex justify-between items-center mb-3 flex-wrap">
                                <div className="flex items-center mb-2 sm:mb-0">
                                    <h3 className="text-lg font-bold text-gray-800 dark:text-white mr-2">
                                        {language === 'ru' ? 'Сгенерированные ключи' : 'Generated keys'}
                                    </h3>
                                    <div className="bg-blue-500 text-white px-2 py-1 rounded-md text-xs">
                                        {totalKeysCount}
                                    </div>
                                </div>
                                <div className="flex space-x-2">
                                    <motion.button
                                        whileHover={{ scale: 1.05 }}
                                        whileTap={{ scale: 0.95 }}
                                        onClick={handleCopyAll}
                                        className={`p-2 ${isCopyingAll ? 'bg-green-500' : 'bg-green-500'} hover:bg-green-600 text-white rounded transition-colors duration-200 text-sm`}
                                    >
                                        <motion.i 
                                            initial={false}
                                            animate={{ scale: isCopyingAll ? [1, 1.2, 1] : 1 }}
                                            transition={{ duration: 0.3 }}
                                            className={`fas ${isCopyingAll ? 'fa-check' : 'fa-copy'} mr-1`}
                                        />
                                        {language === 'ru' ? 'Копировать все' : 'Copy all'}
                                    </motion.button>
                                    <motion.button
                                        whileHover={{ scale: 1.05 }}
                                        whileTap={{ scale: 0.95 }}
                                        onClick={onClearAllKeys}
                                        className="p-2 bg-red-500 hover:bg-red-600 text-white rounded transition-colors duration-200 text-sm"
                                    >
                                        <i className="fas fa-trash-alt mr-1"></i>
                                        {language === 'ru' ? 'Очистить все' : 'Clear all'}
                                    </motion.button>
                                </div>
                            </div>
                            <AnimatePresence>
                                {currentSession && (
                                    <KeySession
                                        key={`current-${currentSession.id}`}
                                        session={currentSession}
                                        onCopy={onCopyKeys}
                                        onClearSession={onClearSession}
                                        onDeleteKey={onDeleteKey}
                                        globalSettings={globalSettings}
                                        isActive={true}
                                        isSelected={selectedSessions?.[currentSession.id]}
                                        onSelect={() => onSessionSelect(currentSession.id)}
                                        copiedKeys={copiedKeys}
                                        game={game}
                                        language={language}
                                    />
                                )}
                                {keySessions && keySessions.map((session) => (
                                    <KeySession
                                        key={`completed-${session.id}`}
                                        session={session}
                                        onCopy={onCopyKeys}
                                        onClearSession={onClearSession}
                                        onDeleteKey={onDeleteKey}
                                        globalSettings={globalSettings}
                                        isActive={false}
                                        isSelected={selectedSessions?.[session.id]}
                                        onSelect={() => onSessionSelect(session.id)}
                                        copiedKeys={copiedKeys}
                                        game={game}
                                        language={language}
                                    />
                                ))}
                            </AnimatePresence>
                        </div>
                    )}
                </div>
            );
        };

        const KeySession = ({ 
            session, 
            onCopy, 
            onClearSession, 
            onDeleteKey, 
            globalSettings, 
            isActive, 
            isSelected, 
            onSelect,
            copiedKeys,
            game,
            language
        }) => {
            const [isCopying, setIsCopying] = useState(false);
            const [isDeleting, setIsDeleting] = useState(false);

            const handleCopy = () => {
                onCopy(session.keys, game, [session.id]);
                setIsCopying(true);
                setTimeout(() => setIsCopying(false), 1000);
            };

            const handleDelete = () => {
                if (!isActive) {
                    setIsDeleting(true);
                    setTimeout(() => {
                        onClearSession(session.id);
                        setIsDeleting(false);
                    }, 300);
                }
            };

            return (
                <motion.div
                    layout
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -50 }}
                    transition={{ duration: 0.3 }}
                    className={`mb-3 p-3 bg-white dark:bg-gray-800 rounded-lg custom-shadow 
                        ${isActive ? 'border-2 border-blue-500' : ''} 
                        ${isSelected ? 'bg-blue-100 dark:bg-blue-900' : ''}`}
                >
                    <div className="flex justify-between items-center mb-2 flex-wrap">
                        <div className="flex items-center">
                            {globalSettings.forPublication && !isActive && (
                                <input
                                    type="checkbox"
                                    checked={isSelected}
                                    onChange={onSelect}
                                    className="mr-2"
                                />
                            )}
                            <h3 className="text-base font-semibold text-gray-800 dark:text-white">
                                {isActive 
                                    ? (language === 'ru' ? "Текущая сессия" : "Current session")
                                    : (language === 'ru' ? `Сессия #${session.id}` : `Session #${session.id}`)
                                }
                            </h3>
                        </div>
                        <div className="flex items-center mt-2 sm:mt-0">
                            <span className="text-xs text-gray-600 dark:text-gray-400 mr-2">
                                {language === 'ru' ? `Ключей: ${session.keys.length}` : `Keys: ${session.keys.length}`}
                            </span>
                            <motion.button
                                whileHover={{ scale: 1.1 }}
                                whileTap={{ scale: 0.9 }}
                                onClick={handleCopy}
                                className={`p-2 ${isCopying ? 'bg-green-500' : 'bg-blue-500'} text-white rounded transition-colors duration-200 mr-1`}
                            >
                                <motion.i 
                                    initial={false}
                                    animate={{ scale: isCopying ? [1, 1.2, 1] : 1 }}
                                    transition={{ duration: 0.3 }}
                                    className={`fas ${isCopying ? 'fa-check' : 'fa-copy'} text-sm`}
                                />
                            </motion.button>
                            {!isActive && (
                                <motion.button
                                    whileHover={{ scale: 1.1 }}
                                    whileTap={{ scale: 0.9 }}
                                    onClick={handleDelete}
                                    className={`p-2 ${isDeleting ? 'bg-red-600' : 'bg-red-500'} text-white rounded transition-colors duration-200`}
                                >
                                    <motion.i 
                                        initial={false}
                                        animate={{ rotate: isDeleting ? 360 : 0 }}
                                        transition={{ duration: 0.3 }}
                                        className="fas fa-trash-alt text-sm"
                                    />
                                </motion.button>
                            )}
                        </div>
                    </div>
                    <AnimatePresence mode="popLayout">
                        <motion.div 
                            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2"
                            layout
                        >
                            {session.keys.map((key, index) => (
                                <motion.div
                                    key={`${session.id}-${index}-${key}`}
                                    layout
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ duration: 0.3 }}
                                >
                                    <KeyCard
                                        keyData={key}
                                        index={index}
                                        onCopy={(key) => onCopy([key], game, [session.id])}
                                        onDelete={(index) => !isActive && onDeleteKey(session.id, index)}
                                        globalSettings={globalSettings}
                                        isActive={isActive}
                                        isCopied={copiedKeys?.includes(key)}
                                        language={language}
                                    />
                                </motion.div>
                            ))}
                        </motion.div>
                    </AnimatePresence>
                </motion.div>
            );
        };

        const KeyCard = ({ keyData, index, onCopy, onDelete, globalSettings, isActive, isCopied, language }) => {
            const [isCopying, setIsCopying] = useState(false);
            const [isDeleting, setIsDeleting] = useState(false);

            const handleCopy = () => {
                onCopy(keyData);
                setIsCopying(true);
                setTimeout(() => setIsCopying(false), 3000);
            };

            const handleDelete = () => {
                setIsDeleting(true);
                setTimeout(() => onDelete(index), 300);
            };

            return (
                <motion.div
                    layout
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -50 }}
                    transition={{ duration: 0.3 }}
                    className={`key-card rounded-lg shadow-md p-2 flex justify-between items-center 
                        ${isDeleting ? 'scale-90 opacity-50' : ''} 
                        ${isCopied ? 'opacity-50 bg-gray-200 dark:bg-gray-700' : ''}`}
                >
                    <div className="flex items-center">
                        <i className="fas fa-key text-gray-600 dark:text-gray-300 mr-1 text-sm"></i>
                        <span className="font-mono text-sm text-gray-800 dark:text-gray-200">#{index + 1}</span>
                    </div>
                    <span className="font-mono text-sm text-gray-800 dark:text-gray-200 truncate flex-grow mx-2">{keyData}</span>
                    <div className="flex space-x-2">
                        <motion.button
                            whileHover={{ scale: 1.1 }}
                            whileTap={{ scale: 0.9 }}
                            onClick={handleCopy}
                            className={`p-2 ${isCopying ? 'bg-green-500' : 'bg-blue-500'} text-white rounded transition-colors duration-200`}
                        >
                            <motion.i 
                                initial={false}
                                animate={{ scale: isCopying ? [1, 1.2, 1] : 1 }}
                                transition={{ duration: 0.3 }}
                                className={`fas ${isCopying ? 'fa-check' : 'fa-copy'} text-sm`}
                            />
                        </motion.button>
                        {!isActive && (
                            <motion.button
                                whileHover={{ scale: 1.1 }}
                                whileTap={{ scale: 0.9 }}
                                onClick={handleDelete}
                                className="p-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors duration-200"
                            >
                                <motion.i 
                                    animate={{ rotate: isDeleting ? 360 : 0 }}
                                    transition={{ duration: 0.3 }}
                                    className="fas fa-times text-sm"
                                />
                            </motion.button>
                        )}
                    </div>
                </motion.div>
            );
        };

        const SettingsModal = ({ globalSettings, setGlobalSettings, onClose, language }) => (
            <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="modal-overlay"
            >
                <motion.div
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.8, opacity: 0 }}
                    className="modal-content bg-white dark:bg-gray-800 rounded-lg p-4 w-96 max-w-full"
                >
                    <div className="bg-gray-900 p-4 rounded-lg mb-4">
                        <label className="flex items-center justify-between text-white">
                            <span className="text-sm">{language === 'ru' ? 'Режим отладки' : 'Debug mode'}</span>
                            <label className="toggle-switch">
                                <input
                                    type="checkbox"
                                    checked={globalSettings.debugMode}
                                    onChange={(e) => setGlobalSettings({...globalSettings, debugMode: e.target.checked})}
                                />
                                <span className="toggle-slider"></span>
                            </label>
                        </label>
                    </div>
                    
                    <div className="mb-4">
                        <h3 className="text-base font-semibold mb-2 text-gray-800 dark:text-white">
                            {language === 'ru' ? 'Настройки копирования' : 'Copy settings'}
                        </h3>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Использовать нумерацию' : 'Use numbering'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.useNumbering}
                                        onChange={(e) => setGlobalSettings({...globalSettings, useNumbering: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Добавлять кавычки' : 'Add quotes'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.useQuotes}
                                        onChange={(e) => setGlobalSettings({...globalSettings, useQuotes: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Добавлять отступ между строками' : 'Add line spacing'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.useLineSpacing}
                                        onChange={(e) => setGlobalSettings({...globalSettings, useLineSpacing: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Использовать оформление с хештегами' : 'Use hashtag formatting'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.useFormatting}
                                        onChange={(e) => setGlobalSettings({...globalSettings, useFormatting: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Копировать ключи всех игр' : 'Copy keys from all games'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.copyAllGames}
                                        onChange={(e) => setGlobalSettings({...globalSettings, copyAllGames: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                    </div>
                    
                    <div className="mb-4">
                        <h3 className="text-base font-semibold mb-2 text-gray-800 dark:text-white">
                            {language === 'ru' ? 'Дополнительные настройки' : 'Additional settings'}
                        </h3>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Для публикации' : 'For publication'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.forPublication}
                                        onChange={(e) => setGlobalSettings({...globalSettings, forPublication: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                        <div className="mb-2">
                            <label className="flex items-center justify-between">
                                <span className="text-sm text-gray-700 dark:text-gray-300">
                                    {language === 'ru' ? 'Удалять после копирования' : 'Delete after copying'}
                                </span>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={globalSettings.deleteAfterCopy}
                                        onChange={(e) => setGlobalSettings({...globalSettings, deleteAfterCopy: e.target.checked})}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </label>
                        </div>
                    </div>
                    
                    <motion.button
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                        onClick={onClose}
                        className="w-full p-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors duration-200 text-sm"
                    >
                        {language === 'ru' ? 'Закрыть' : 'Close'}
                    </motion.button>
                </motion.div>
            </motion.div>
        );

        const DeleteConfirmationModal = ({ onConfirm, onCancel, language }) => (
            <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="modal-overlay"
            >
                <motion.div
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.8, opacity: 0 }}
                    className="modal-content bg-white dark:bg-gray-800 rounded-lg p-4 w-96 max-w-full"
                >
                    <h3 className="text-lg font-semibold mb-4 text-gray-800 dark:text-white">
                        {language === 'ru' ? 'Подтверждение удаления' : 'Delete confirmation'}
                    </h3>
                    <p className="mb-4 text-gray-600 dark:text-gray-300">
                        {language === 'ru' 
                            ? 'Вы уверены, что хотите удалить скопированные ключи?' 
                            : 'Are you sure you want to delete the copied keys?'}
                    </p>
                    <div className="flex justify-end space-x-2">
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={onCancel}
                            className="p-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded transition-colors duration-200"
                        >
                            {language === 'ru' ? 'Отмена' : 'Cancel'}
                        </motion.button>
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={onConfirm}
                            className="p-2 bg-red-500 hover:bg-red-600 text-white rounded transition-colors duration-200"
                        >
                            {language === 'ru' ? 'Удалить' : 'Delete'}
                        </motion.button>
                    </div>
                </motion.div>
            </motion.div>
        );

        const ClearConfirmationModal = ({ onConfirmCurrent, onConfirmAll, onCancel, language }) => (
            <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="modal-overlay"
            >
                <motion.div
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.8, opacity: 0 }}
                    className="modal-content bg-white dark:bg-gray-800 rounded-lg p-4 w-96 max-w-full"
                >
                    <h3 className="text-lg font-semibold mb-4 text-gray-800 dark:text-white">
                        {language === 'ru' ? 'Подтверждение очистки' : 'Clear confirmation'}
                    </h3>
                    <p className="mb-4 text-gray-600 dark:text-gray-300">
                        {language === 'ru' ? 'Выберите режим очистки:' : 'Choose clearing mode:'}
                    </p>
                    <div className="flex flex-col space-y-2">
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={onConfirmCurrent}
                            className="p-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors duration-200"
                        >
                            {language === 'ru' ? 'Только для этой игры' : 'Only for this game'}
                        </motion.button>
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={onConfirmAll}
                            className="p-2 bg-red-500 hover:bg-red-600 text-white rounded transition-colors duration-200"
                        >
                            {language === 'ru' ? 'Для всех игр' : 'For all games'}
                        </motion.button>
                        <motion.button
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={onCancel}
                            className="p-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded transition-colors duration-200"
                        >
                            {language === 'ru' ? 'Отмена' : 'Cancel'}
                        </motion.button>
                    </div>
                </motion.div>
            </motion.div>
        );

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
